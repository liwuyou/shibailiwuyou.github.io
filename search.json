[{"title":"arduino的系统学习","path":"/2023/09/29/arduino的系统学习/","content":"我还是决定系统学一下arduino，虽然系统学，但仍是速成，由于碰到一些事情我意识到自己还不够努力，就从arduino开始吧 arduino IDE下载 www.arduino.cc arduino uno引脚图 Arduino UNO是基于ATmega328P的Arduino开发板。它有14个数字输入&#x2F;输出引脚（其中6个可用于PWM输出）、6个模拟输入引脚，一个16 MHz的晶体振荡器，一个USB接口，一个DC接口，一个ICSP接口，一个复位按钮。它包含了微控制器所需的一切，你只用简单地把它连接到计算机的USB接口，或者使用AC-DC适配器，再或者用电池，就可以驱动它。 存储空间ATmega328 有32KB Flash存储空间（其中0.5KB被用于存储bootloader），2KB 的SRAM和1KB 的EEPROM。可以使用官方提供的EEPROM库读写EEPROM空间。 输入输出Arduino Uno有14个数字输入输出引脚，可使用 pinMode()、digitalWrite() 和 digitalRead() 控制。其中一些带有特殊功能，这些引脚如下 Serial0（RX）、1（TX），被用于接收和发送串口数据。这两个引脚通过连接到ATmega16u2来与计算机进行串口通信。 外部中断2、3，可以输入外部中断信号。中断有四种触发模式：低电平触发、电平改变触发、上升沿触发、下降沿触发。 PWM输出：3、5、6、9、10、11，可用于输出8-bit PWM波。对应函数 analogWrite() 。 SPI：10（SS）、11（MOSI）、12（MISO）、13（SCK），可用于SPI通信。可以使用官方提供的SPI库操纵。 L-LED：13。13号引脚连接了一个LED，当引脚输出高电平时打开LED，当引脚输出低电平时关闭LED。 TWI：A4（SDA）、A5（SCL）和TWI接口，可用于TWI通信，兼容I²C通信。可以使用官方提供的Wire库操纵。 点亮一个LED灯点灯大师，闪亮登场LED灯正负两端会有2v的电压差 pinMode(引脚号，状态) 设置引脚模式 输出(OUTPUT) 输入(INPUT) 输入上拉模式(INPUT_PULLUP) digitalWrite(引脚号,状态); 引脚输出状态 HIGH(高电平) LOW(低电平) 上拉电阻arduino开发板上拉电阻10K 引脚悬空引脚设置成INPUT却没有加任何电路，引脚检测状态不定（0&#x2F;1） 123456789//点亮二号引脚void setup() &#123; pinMode(2,OUTPUT);&#125;void loop() &#123; digitalWrite(2,HIGH);&#125; 串口通信digitalRead(引脚号)读取某个引脚状态，常与pinMode(引脚号,INOUT)搭配使用 Serial.begin(9600);串口初始化设置9600为常用波特率 Serial.println(打印内容);在电脑的串口监视器上输出相应内容 delay(时间)延时函数，单位为ms 12345678910void setup() &#123; pinMode(2,INPUT); Serial.begin(9600);&#125;void loop() &#123; int buttonState = digitalRead(2); Serial.println(buttonState); delay(1);&#125; 引脚悬空 模拟输出标有~的数字引脚可输出PWM信号 analogWrite(Pin,bringtness)模拟输出，Pin,引脚号; brigngness为亮度范围0~255,输出的为Pwm信号，PWM信号的频率大约为490Hz.在Arduino UNO控制器中，5号引脚和6号引脚的PWM频率为980Hz。 呼吸灯（周期未测）12345678910111213141516void setup() &#123; Serial.begin(9600);&#125;void loop() &#123;for (int brightness = 0;brightness &lt;= 255;brightness+=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;for (int brightness = 255;brightness &gt;= 0;brightness-=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;&#125; 模拟输入电位器电位器 ananaloRead(Pin)读取范围0-5v,返回0~1023的数值，读入的最大频率为10 000次，引脚悬空状态读的数值不定 变量B &#x3D; map(变量A,A_min,A_max,B_min,B_max)将变量A等比映射到变量B 1234567891011void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; int a = map(analogRead(A0),0,1023,0,255); Serial.println(a); delay(10);&#125; 电机驱动电机种类 直流电机(DC) 交流电机(AC) 交直流两用电机(Universal) 使用arduino的引脚直接驱动直流电机简直蠢爆了，引脚输出电流不够,pwm给小了根本不动，当然，这里只是验证analogWrite是PWM信号，周期490Hz 12345678void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; analogWrite(9,200);&#125; 引脚直接驱动电机 舵机驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 SG90舵机 12345678910111213141516171819202122232425262728293031323334353637383940/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 舵机驱动 步进电机驱动步进电机优点 精准控制电机输出轴角度 低速运行时扭矩大 开环控制&#x2F;性价比高 步进电机的分类 单极性步进电机 5-6条引脚，相对输出扭矩低，控制简单 双极性步进电机 4条引脚，相对输出扭矩高，控制复杂 步进电机的参数 额定电流 额定电压 定位转矩 不通电 保持转矩 通电 相数 可独立通电的定子电磁线圈数步进电机详解 http://t.csdnimg.cn/TkxCb","tags":["ardunio"]},{"title":"gazebo的学习与应用","path":"/2023/09/26/gazebo的学习与应用/","content":"学习目标与任务 Gazebo和环境模型设计 机器人模型设计 为模型上装备传感器与执行器 https://gazebosim.org/docs","tags":["ros"]},{"title":"基于古月居的ros入门","path":"/2023/09/21/基于古月居的ros入门/","content":"前言由于前段时间的学习总结的习惯不好，决定新开一栏用于ros基础学习。有一说一，通过和学长的进度比较，总感觉自己是个废物。 虚拟机的安装不要装机械盘，运行慢。使用VMwareubantu系统18 linux基本命令行123456789101112cdlsmvrm -rcppwdmkdirtouchshutdown -h nowrebootsudo 基本命令行12sudo apt-get update //更新源source ~/catkin_ws/devel/setup.bash //刷新环境变量 前置安装123456789//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim//ros安装wget http://fishros.com/install -O fishros &amp;&amp; . fishros ros的核心概念节点（node）与节点管理器（ros master）节点名称唯一 话题(topic)与服务(serve) 话题：单向 发布者 订阅者 消息(massage):话题的数据由.msg文件定义 服务：双向 客户端 服务端 .srv文件定义命名请求应答数据 参数(parameter)—全局共享字典适合静态，非二进制的配置参数 文件系统 功能包（package） ：含节点源码，配置文件，数据定义 功能包清单： 作者信息，许可信息，依赖选项 元功能包：组织多个同一目的的功能包 ros命令行工具123456rostopicrosservicerosnoderosparamrosmsgrossrv 小海龟123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 工具123456789rqt_graph //节点可视化rosnode //显示节点rostopic //话题 pubrosmsgrosservice //服务 callrosbag record -a -O cmd_record //话题记录 cmd_record位保存文件名，默认hom目录下rosbag play cmd_record.bag //话题复现 ros的文件结构文件结构 1234567891011121314151617181920212223242526272829303132WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 创建工作空间123456789101112131415//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_makecatkin_make install //可要可不要//设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash 问题：我需要在原有的ROS工程基础之上，新建一个ROS功能包。我直接复制了其他目录下原有的一个包，进行修改。然后问题来了：catkin_make后竟然没有反应。甚至没有检测到我新改写的cmake 解决：ros允许多个工作空间使用相同功能包，但多个工作空间source不要放在脚本里，手动敲，否则会被覆盖,在catkin_make之前source一下，之后再source一下。而且要多次执行，如下。注意要先开下roscore，py文件要给其可执行权限. 123456//将文件复制过来后，在工作空间目录下打开终端source ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bash 脚本文件的source只在新的终端开启时才运行 发布者与订阅者以海龟为例 python文件要记得给可执行权限 发布者123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher():\t# ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True)\t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)\t#设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 订阅者123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber():\t# ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True)\t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)\t# 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 消息的自定义定义msg文件在功能包的src同级目录下创建msg文件夹12345678910// 举例，该文件名为Person.msgstring nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 launch文件使用 launch 文件，可以一次性启动多个 ROS 节点launch文件自动启动ROS Master 123456789101112131415161718192021&lt;!-- 包名 节点名称 自定义节点名 --&gt;&lt;!-- 注释 --&gt;&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt; &lt;!-- 参数设置 --&gt; &lt;param name=&quot;output_feame&quot; value=&quot;odom&quot;/&gt; &lt;!-- name:参数名称，value 参数值 --&gt; &lt;rosparam= file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!-- 重映射remap --&gt; &lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt; &lt;!-- from:原名 to:映射后的名字 --&gt; &lt;!-- 嵌套include --&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 客户端与服务端客户端 rosservice call &#x2F;clear “{}” 参数的使用parameter Server 全局变量存储空间 123456789101112// 列出当前有多个参数rosparam list// 显示某个参数值rosparam get param_key// 设置某个参数值rosparam set param_key param_value//保存参数到文件rosparam dump file_name// 从文件读取参数rosparam load file_anme// 删除参数rosparam delete param_key yaml 参数文件在程序里实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config():\t# ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True)\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;);\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() TF坐标管理系统tf功能包，默认10秒 实现机制 广播TF变换 监听TF变换12345678//安装功能包sudo apt-get install ros-melodic-turtle-tf//启动节点roslaunch turtle tfturtle tf demo.launch//turtles键盘控制节点rosrun turtlesim turtle teleop_key//保存tf tree为 pdf 至当前目录rosrun tf view frames tf工具 命令行工具rosrun tf tf_echo turtle1 turtle2 可视化工具 rosrun rviz rviz -d rospack find turtle tf &#x2F;rviz&#x2F;turtle rviz.rviz tf坐标的广播与监听单词释义quaternion 四元数radian 弧度degree 角度 常用可视化工具QT工具箱 日志输出rqt_console 计算图ret_graph 数据绘图rqt_plot 图像渲染rqt_image_view rviz gazebo 进阶 控制与仿真 gazebo + ros +ros_control","tags":["ros"]},{"title":"stc驱动TM1608","path":"/2023/09/16/stc驱动TM1608/","content":"tm1638.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef _TM1638_H#define _TM1638_H#include &lt;STC32G.H&gt;//TM1638模块引脚定义sbit DIO=P1^3; //数据线sbit CLK=P1^0; //时钟线sbit STB=P1^1; //片选线//共阴数码管显示代码unsigned char code dis[11]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x00&#125;; unsigned char while_one[8]=&#123;0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce&#125;;void TM1638_Write(unsigned char Data) //写数据函数&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; CLK=0; DIO=Data&amp;0x01; Data&gt;&gt;=1; CLK=1;\t&#125;&#125;void Write_Command(unsigned char Command) //发送命令&#123;\tSTB=0;\tTM1638_Write(Command);\tSTB=1;&#125;void Write_Data(unsigned char add,unsigned char Data) //指定地址写入数据&#123;\tSTB=0;\tTM1638_Write(0x00|add);\tTM1638_Write(Data);\tSTB=1;&#125;//TM1638初始化函数void init_TM1638(void)&#123;\tunsigned char i;\tWrite_Command(0x8F); Write_Command(0x40); //采用地址自动加1\tSTB=0; TM1638_Write(0xc0); //设置起始地址\tfor(i=0;i&lt;16;i++) //传送16个字节的数据 TM1638_Write(0x00);\tSTB=1;&#125;#endif tm1638.c 123456789101112131415161718192021#include &lt;STC32G.H&gt;#include &quot;tm1638.h&quot;void TMmain(void)&#123; unsigned char i;\tP0=0xff;P2=0x80;P2&amp;=0x1f; P0=0;P2=0xa0;P2&amp;=0x1f; //关闭单片机LED、蜂鸣器、继电器，主要是刺眼。。。 init_TM1638(); //初始化TM1638\tfor(i=0;i&lt;8;i++)\tWrite_Data(i,dis[10]); //初始化寄存器\twhile(1)\t&#123; Write_Data(while_one[0],dis[6]); //选中GRID1，令第一位数码管显示0\t&#125;&#125;","tags":["单片机"]},{"title":"stc32学习","path":"/2023/09/14/stc32学习/","content":"时隔三月，再摸单片机，这一次我要把遗忘的全部拿回来 STC32介绍 STC I&#x2F;O口工作模式 除了P3.0和P3.1（准双向口）外，其他默认高阻输入模式准双向口和推挽输出模式默认为高电平 define和typedef12typedf unsigned char u8;给已存在的数据类型起别名 WTST程序读取等待控制寄存器，上电默认为70-255 volatile设置变量，防止优化 预编译处理12345678910//主要命令有#include#ifndef //如果宏未定义则执行#define //定义宏#endif //结束有if的定义#elif#undef // 取消已定义的宏#line#program#error 模块化编程思想 移位法点亮LED 1234567while(1)&#123; for(i = 0;i &lt; 8; i++) &#123; P2 = ~(0x01 &lt;&lt; i); delayms(500); &#125;&#125; 上拉电阻和下拉电阻所有IO口都配置了一个4.1K的上拉电阻和10K的下拉电阻都是8位寄存器上拉电阻控制寄存器：PxPU上拉电阻控制寄存器：PxPD(x &#x3D;0,1,2,3,4,5,6,7) 123456789P7M1 = 0xFF;P7M0 = 0x00; //高阻输入模式EAXFR = 1; //使能XFR,特殊寄存器，设置使之能访问while(1)&#123; P7PU = 0x01; //加上拉电阻等于准双向口模式 delayms(1000); P&amp;PD = 0x00; delayms(1000);&#125; 自适应delayms()函数12345678#define MAIN_Fose = 35000000 //设置主频void delayms(int ms)&#123; int i; do&#123; i = MAIN_Fose/6000; while(i--); &#125;while(--ms);&#125; 特殊功能寄存器（SFR，XFR）地址范围0x7E0000-0x7EFFF如需访问扩展寄存器，需先设置SFR使能寄存器CKCON 外部数据总线时钟控制寄存器CKCON &#x3D; 0x00;(上电默认为7，建议设为0) 74HC595独立按键定时器与计数器5个24位定时器&#x2F;计数器（八位预分频+16位计数）","tags":["单片机"]},{"title":"社团成员基本学习路线及其介绍","path":"/2023/09/05/社团成员基本学习路线及其介绍/","content":"本文档用于告知新生社员基本的学习路线，学习方向。该文档同步发布在我的个人博客(liwuyou.github.io)以及3D打印社网站(cumtb.club)上个人意见，仅供参考如果对学习路线有疑问或者不了解的地方，请联系社长或管理员 学习路线语言类 c&#x2F;c++ python English 单片机类 arduino –&gt; esp32 51单片机 –&gt; stm32 树莓派&#x2F;香橙派 硬件类 电脑装配及结构认识 solidworks基本使用 基本元器件使用及选型 原理图及pcb板的绘制 元件焊接工艺 软件类 github的使用 chatgpt的使用 基本网络知识及电脑工具使用 ros基本了解 linux学习 神经网络学习 个人博客搭建 具体介绍请注意学习路线里面的，并不是所有内容都要学。 首先呢，语言类方面，我们要学习一门编程语言，如果你想走嵌入式开发c是必选的，如果你想走更偏软件一点的机器学习，人工智能的路线，推荐学习python，如果更偏向于算法，对计算机更加细致入微的调控请选择C++。北矿的我们，大一上学期学的是python，但是课程很水，两节课就可以讲完所有的python基本语法，课程简单，基本不会挂科。大一下学期学的是C语言，蛮重要的，会考试，分数占比大，容易挂科。推荐入门，语言使用c，理由如下，下学期要学C语言，提前预习，可获得更高分数，或者获得更多的空余时间。然后尽量把英语学好，特别是在外网的时候，英语就很重要了，当然不会，也没有关系。用翻译软件也能解决，但是翻译软件并不能适用于所有场景，所以英语还是尽量学好一点 而在单片机类中，什么是单片机，请自行百度，了解什么是单片机，单片机的常见类型。为什么要学习单片机呢？单片机是嵌入式开发学习的基本环节，学会了使用单片机，我们可以设计一些具有一些实用价值的东西，如智能门锁，烟雾报警器，联网天气显示时钟等。我们目前使用的单片机类型有很多，而最简单的最好入门的最容易上手的是arduino，arduino开发套件，淘宝上买的话，大概100多块钱，闲鱼上二手更便宜。Arduino，开发简单，开源库多，资料较多。arduino学完下一步就可以使用，arduino的开发环境，开发esp32，Esp 32是一款性能更加强大，具有联网和蓝牙功能的单片机，价格低廉。如果不从arduino入手的话，也可以从51单片机进行入门，51单片机是stm32单片机的前置课程，直接上手stm 32难度较大，学完51更容易上手。Stm32是当前使用规模最大的单片机类型之一，功能强大，性能优越，能够完成很多复杂的工作，如果方向是嵌入式的话，很难不接触到stm 32这款单片机。而且stm 32也是大学生毕业设计的首选单片机之一。然后就是树莓派和香橙派以及其他什么派，从某种意义上来讲，这些派应该不属于单片机类型，他们可以连接屏幕，充当电脑，甚至安装WINDOWS系统使用。当然了，他们性能没有电脑这么强。一般他们都安装Linux系统进行开发，充当上位机使用。如自动导航小车的上位机。性能十分强大，价格也昂贵。 而硬件类方向，如果你是传统工科专业，可能不可避免要接触到一些元器件的选型，和PCB板原理图的绘制。简单来说就是做一块完整的，能够正常使用的电路板。再介绍一下solidwords，具体使用请参照，零基础小白3d打印基本入门，这篇文章。这是一款功能强大的软件，可以用于3d建模，然后将建模好的文件导出进行3d打印。他是我们3d打印社成员，必须要掌握的一款软件。而电脑的装配及结构认识，如果你有兴趣的话，我们可以和你一起组装电脑，当一名图吧垃圾佬。我们实验室的电脑都是自己组装的，自己在网上淘CPU，显卡，机箱等 而在软件类方向，我们首先第一步是科学上网，这一步自行领悟。然后使用github，github是开源社区开源社区里面有很多开源的项目和代码，计算机类必备。然后还要学习一些基本的电脑工具软件，如资源管理器，powershell等Linux系统是我们开发的常用系统，特别是在机器人领域， 机器人开发平台ros，就是在Linux系统上开发的，像很多服务器，都搭载在Linux系统上。Linux系统相对于WINDOWS系统具有轻量化，稳定性的优点。十分建议学习。如果你python学的好的话，还可以进阶学习神经网络的相关知识，如视觉识别相关的open CV,yolo等 最后，对学习路线进行一下小小的总结。以下有几种路线以供选择，难度依次增大注意难度与实用并不相关。 最快最轻量的路线 语言类的c，硬件类的soildwords，单片机类的arduino，esp32 稍微复杂一点 语言类的python，c，硬件类的soildwords，单片机类的51，stm32 再复杂一点 语言类的python，c，硬件类的，pcb绘制，solidwords，单片机类的，arduino，esp32，stm32，软件类的linux开发 而第一学期，新生适宜参加的一些比赛有，校巡线车比赛，蓝桥杯比赛 最后，感谢你看到这里，如果内容有什么错误，请及时跟我们联系，如果有什么想法，可以和我们交流。谢谢","tags":["社团"]},{"title":"python study","path":"/2023/08/10/python-study/","content":"python规范- 结尾空一行- 导入库空两行- 注释# 空一格Python库的安装1pip install 库名","tags":["python"]},{"title":"links","path":"/2023/07/30/links/","content":"图标 介绍 网址 triority’s blog https://triority.cn/ 天鹅绒房间 https://qwqpap.xyz/ 北矿3D打印社 https://cumtb.club/"},{"title":"hexo一些问题的解决","path":"/2023/07/30/hexo一些问题的解决/","content":"hexo部署到github的报错解决报错如下 1234567891011fatal: unable to access &#x27;https://github.com/liwuyou/liwuyou.github.io.git/&#x27;: Failed to connect to github.com port 443 after 21100 ms: Couldn&#x27;t connect to serverFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (D:\\blog\\wj ode_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:514:28) at cp.emit (D:\\blog\\wj ode_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal/child_process:291:12) 为什么出现这个问题？网络代理问题或者网速不好（几率小） 如何解决？打开_config.yml找到 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: main repo改为 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: main 其中yourname改为你自己的github用户名 网络其他热门解决方法","tags":["hexo"]},{"title":"arduino小项目2——电压表","path":"/2023/07/30/arduino小项目2——电压表/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕，小按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V; void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; float a = Voltage_detect(); displayMenu(a);&#125; //oled屏幕显示void displayMenu(float a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); u8g2.print(&quot;Voltage, (0-5v)&quot;); // 显示电压表... u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.setCursor(20, 34); u8g2.println(a); u8g2.sendBuffer();&#125; //检测并转化为0-5vfloat Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); //读取io口模拟值 float Voltage = analogdate*5.0/1023.0; //转化 //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); //串口打印 &#125; else Serial.println(Voltage); return Voltage; //返回值&#125; 本来想弄万用表来着，emmp,放弃了,没写完，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int gear = 0; // 万用表状态 0.菜单；1.电压表；2.电流表；3.电阻表int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V;int R_I=220; // 电流表状态，电阻为220欧姆 void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; double a = Voltage_detect(); switch1(); displayMenu(a); int analogdate = analogRead(A0); &#125; void switch1() &#123; int key = digitalRead(2); // 第一次判断 if (key == 0) &#123; // 延时20ms 消除按键抖动 delay(20); // 第二次判断 if (key == 0) &#123; gear++; // 状态++ if (gear &gt; 3) &#123; gear = 0; // 循环到第一个菜单状态 &#125; &#125; // 等待按键被松开 while (!digitalRead(2)) &#123; // 等待按键松开 &#125; &#125;&#125; void displayMenu(double a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); switch (gear) &#123; case 0: //u8g2.print(&quot;Menu&quot;); // 显示菜单选项... face(); break; case 1: u8g2.print(&quot;Voltage&quot;); // 显示电压表... u8g2.setCursor(20, 34); u8g2.println(a); break; case 2: u8g2.print(&quot;Current&quot;); // 显示电流表... break; case 3: u8g2.print(&quot;Resistance&quot;); // 显示电阻表... break; &#125; u8g2.sendBuffer();&#125; void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; float Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); float Voltage = analogdate*5.0/1023.0; //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); &#125; else Serial.println(Voltage); return Voltage;&#125;","tags":["arduino"]},{"title":"arduino小项目1——小时钟","path":"/2023/07/30/arduino小项目1——小时钟/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕 接线图，文字描述。单片机上的A4接小屏幕上的SDA，A5接SCL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;MsTimer2.h&gt;#include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int year = 2020, month = 1, day = 1, hour = 0, minute = 0, second = 0; void onTimer() &#123; second++; if (second &gt;= 60) &#123; second = 0; minute++; if (minute &gt;= 60) &#123; minute = 0; hour++; if (hour &gt;= 24) &#123; hour = 0; &#125; &#125; &#125;&#125; void setup() &#123; Serial.begin(9600); u8g2.begin(); u8g2.clearBuffer(); MsTimer2::set(1000, onTimer); // 中断时间为1秒 MsTimer2::start(); // 启动定时器&#125; void loop() &#123; displayTime();&#125; void displayTime() &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.drawStr(0, 15, &quot;TIME:&quot;); u8g2.setFont(u8g2_font_ncenB12_tr); char strTemp[12]; sprintf(strTemp, &quot; %d.%.2d.%.2d&quot;, year, month, day); u8g2.drawStr(35, 15, strTemp); u8g2.setFont(u8g2_font_ncenB14_tr); sprintf(strTemp, &quot;%.2d.%.2d.%.2d&quot;, hour, minute, second); u8g2.drawStr(25, 45, strTemp); u8g2.sendBuffer();&#125;","tags":["arduino"]},{"title":"markdown基本介绍与语法","path":"/2023/07/26/markdown基本介绍与语法/","content":"markdown是什么？Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等 我为什么使用markdown写个人博客需要，且markdown使用简单，b站搜索十分钟学会，word无法完成个人博客的书写.markdown和word可相互转化,但效果不好，排版问题较大。markdown无法实现精细排版要求。 在线编译器网址https://markdown.com.cn/editor/在线转化器网址https://www.easeconvert.com/markdown-to-word/ 基本语法12345678910111213141516171819202122232425262728293031323334353637383940——————标题——————# 一级标题## 二级标题### 三级标题...###### 六级标题——————字体———————**这个是粗体***这个是斜体****这个是粗体加斜体***~~这里想用删除线~~--- 分割线——————列表———————无序列表的使用，在符号`-`后加空格使用有序列表的使用，在数字及符号`.`后加空格后输入内容——————图片———————使用符号&gt;&gt; 引用内容——————表格———————可以使用冒号来定义表格的对齐方式，如下：| 姓名 | 年龄 | 工作 || :----- | :--: | -------: || 小可爱 | 18 | 吃可爱多 || 小小勇敢 | 20 | 爬棵勇敢树 || 小小小机智 | 22 | 看一本机智书 |——————链接———————[描述](链接)——————图片———————![描述](链接)——————代码———————```语言代码块``` (占位，不管) 笔记over","tags":["markdown"]},{"title":"ros车基本学习（基于讯飞车）","path":"/2023/07/24/ros车基本学习/","content":"ros是什么（个人理解）ros是个机器人操作系统，可以在上面实现对机器人的操作，好比一个工作台，别人给你造好，直接使用上面的工具方便造自己的作品. 我为什么学ROS竞赛需要,智能车讯飞比赛及人工智能比赛甚至电赛控制类赛题也能用到 代码系统是乌班图18的系统。 123456//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim 代码运行实例（c++） 123456789101112//终端输入，在主目录下创造一个test的文件夹。mkdir test//创建一个名为hello的点cpp文件。touch hello.cpp//在文件中写入内容//写完后保存关闭//打开终端输入,编译C加加文件g++ hello.cpp -o hello//执行可执行文件。./hello//同理。执行python文件python hello.py ros安装 1234567891011121314151617181920//添加ros软件源sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; //添加密匙sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 //安装rossudo apt updatesudo apt install ros-melodic-desktop-full //初始化rosdepsudo rosdep initrosdep update //设置环境变量echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc //安装rosinstallsudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 鱼香ros一键安装 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 小乌龟实例 123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 创建工作空间 1234567891011121314//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_make //设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译 12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs geometry_msgs turtlesim //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash C++编译配置&lt;cmakelists.txt&gt;12add_executable($&#123;PROJECT_NAME&#125;_node src/my_package_name_node.cpp)target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;)自定义消息1.在功能包文件夹内创建msg文件夹，并新建Person.msg文件，在里面写入 1234567string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 2.在package.xml文件内添加依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.在CMakeLists.txt内加入： 123456789 add_message_files( FILES Person.msg) generate_messages( DEPENDENCIES std_msgs)并把1# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim改为1CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime系统关机及重启 1234//关机shutdown -h now//重启sudo reboot ctrl all+T打开新的终端 摄像头参数命令1qv4l2","tags":["ros"]},{"title":"零基础小白3d打印基本入门（2.0）","path":"/2023/07/24/3D打印入门基础/","content":"欢迎加入3d打印社温暖的大家庭 本手册旨在帮助新同学完成3d打印从0到1的过程 第一步 建模软件的安装建模软件有很多，如有其他需求请自行查找。这里主要介绍一种，北矿的我们用的最多的软件。Solidwords Solidwords是工业建模软件，主要用于工业零部件的建模。安装其实有点小复杂。安装需谨慎，请严格按照规范进行。这玩意儿实际上是付费软件（用于学习的话，是可以白嫖的。），本人实际安装的时候，因为安装时出现一些差错。只能把电脑系统重装了软件图标 基本界面 具体安装方法下载路径：https://www.cadzxw.com/download.html打开网址后，菜单下拉。找到solidwords的一栏。选择最新版solidwords安装图文教程点击查看。 在此再次提醒各位，安装需谨慎，请严格按照安装操作进行。(我想你大概也不想重装电脑吧[狗头])不愿折腾的可选择淘宝远程指导，但十分不推荐。 按照上面的操作，一步一步的来就可以安装完毕了。下面进入到第二步 第二步 建模软件的学习依旧是以solidwords为例（如果安装了其他建模软件的话，请自行查找教程）在B站上可以找到学习的教程。这里推荐阿奇学solidwolds.https://www.bilibili.com/video/BV1iw411Z7HZ/链接如上。建模软件的学习，请自行按照视频进行。学习完了建模软件就可以开始3d打印了吗？还差最后一步。 第三步 开始3d打印首先需要一台电脑，一台打印机，一个U盘，一个已经建模好的模型。建模软件。切片软件。（当然了，模型也可以在各大网站上去找。）切片软件有很多，请自行查找。但是学校的打印机很垃圾。需要配备专门的切片软件，也就是说，市场上通用的切片软件，eg.cura实际上是用不了的。哦，也可以用，但是切出来的不能够用于学校的打印机，只能够用于自制的打印机，或者是其他品牌的打印机。专门的切片软件链接放在这里，请自行下载。https://cr.triority.cn/f/LRHZ/SHINING_Setup_5.2.6.exe切片软件图标: 这个链接的存活取决于mjx学长服务器的存活时间.请注意保存。 3d打印模型的获取方式 blbl t站 建模软件手绘 (机械学生展示你的实力吧) 这里我将会演示一下。依旧是基于solidwords1.打开solidwords的已建好的模型。 2.选择文件另存为（在这之前请保存好你的文件，快捷键Ctrl+s.如果已经保存，请忽略括号内容） 3.点击后弹出界面如下图所示 请选择文件名,并点击保存类型。找到stl格式.保存.(STL(Stereolithography)文件，有时被称为“标准三角语言”或“标准曲面细分语言”，由3D Systems于1987年创建，并且已被广泛用作全行业3D打印机模型的标准文件。)学校的打印机专用的切片软件只能识别stl格式.接下来会弹出一系列界面。选按照默认选择是就可以了。然后你的保存路径里会出现这样一文件。如图。(因为我直接保存在桌面上了)（这种文件一般发给淘宝商家就可以打印了。） 打开这个文件。会出现如下的界面 右侧是调参界面。我简单的介绍一些重要的吧首先，右侧的材料一栏。(社团买的材料。主要是PLA，有时也有ABS。)然后就是添加支撑这一栏。如果说你的材料有镂空结构。请添加支撑。不然的话，打印的时候会塌掉。（当然，你也可以利用支撑的特性做出一些其他作品。） 在此展示一下20级sk学长的作品。圣诞树.没有添加支撑。让其自然下落而形成的圣诞树结构。他的建模模型和实际图完全不一样。实际图是没有添加支撑的塌掉的建模模型。切片软件左侧一栏可以移动调整打印件的位置和方向。点击立方体打印件，左侧就会变成可选状态。常用功能有移动，缩放，旋转。（多尝试几遍就熟悉了。）摆好模型的位置。使它变成一个容易打印的状态。这一点比较重要，如果模型的位置和方向不好的话。可能会使打印机打印时失败。。 摆好模型的位置，并调整参数后。点击右下角的准备按钮。并插上U盘。这里建议最好用学校的U盘。自己的U盘的话，插上去可能会检测不出来。 学校的U盘如上图。切片完成后，点击右下角的保存到可移动磁盘。拔出U盘，将U盘插入打印机。打印机全貌 右上角是打印机的菜单界面，点击打印，下翻目录，找到我们要打印的立方体模型。点击三角形开始打印。这样我们只需要等待打印完成就可以了。 第四步 打印机的维护打印机的维护，包括内容有：（实际打印中，我们会碰到的最多的问题。）1.耗材安装2.打印机调平3.堵头问题怎么处理当然了，这里也放一个学校打印机的官方的维护视频的链接链接：https://pan.quark.cn/s/714267f196f7当然了，如果在实际使用过程中碰到了一些无法解决的问题，请积极的请教学长。因为实际维修的过程可能跟官方给的教程有很大差异。 附录 作品展示 进阶 如何制作一台3d打印机https://www.bilibili.com/video/BV15N411o7ou?p=1&amp;vd_source","tags":["3d打印"]},{"title":"我的技术栈","path":"/2023/07/24/我的技术栈/","content":"我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32(未学) stm32(未学) 网络基础 树莓派 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"this is my blog","path":"/2023/07/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的个人博客姓名：李无忧性别：男爱好：睡觉和吃饭以及听音乐性格：温和喜静理想：实现共产主义，追求社会公平讨厌的事：被他人意志所裹挟擅长的事：模仿与学习 为什么写博客？ 主要原因有二个方面吧，首先呢，记录学习状态。学习的时候很多代码确实很难记住，知道怎么用就好了，必要的时候翻翻个人博客就可以找到。然后吧，记录生活日常。当然这个可能比较少。"}]