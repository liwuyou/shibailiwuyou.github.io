[{"title":"numpy库的学习","path":"/2023/10/24/numpy库的学习/","content":"参考资料 https://www.runoob.com/numpy/numpy-tutorial.html 线性代数基础概念理解线性代数的概念忘了，这里补一补 https://zhuanlan.zhihu.com/p/422251943 numpyNumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C&#x2F;C++&#x2F;Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能","tags":["python"]},{"title":"python的os库的使用","path":"/2023/10/22/python的os库的使用/","content":"参考资料 https://blog.csdn.net/m0_55697123/article/details/119464001 https://blog.csdn.net/wulishinian/article/details/106420532 Alt text 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport time# print(os.system(&#x27;C:\\\\Windows\\\\System32\\\\calc.exe&#x27;))print(os.name) # linux 显示posixprint(os.environ) # 环境变量# windows \\ , linux /# 常用系统相关变量，sep分隔符print(os.sep)print(os.pathsep)print(os.linesep)# 文件和目录操作# os.mkdir(&quot;test&quot;) # 在当前路径下创建目录# os.rmdir(&quot;test&quot;) # delete目录# os.remove(&quot;文件名&quot;) #delete文件print(os.getcwd()) # 打印当前目录# os的子模块 os.pathfile = os.getcwd()+&quot;/main.py&quot;print(os.path.split(file)) # 分割文件名和路径mkdir, filename = os.path.split(file)print(filename)# 判断绝对路径与相对路径print(os.path.isabs(file)) # 是绝对，则返回TRUE# 判断文件或目录是否存在print(os.path.exists(file))# 拿到目录或文件最后修改时间，开始创建时间print(os.path.getatime(file)) # 显示时间戳print(os.path.getctime(file)) #print(os.path.getsize(file)) # 拿到文件大小,字节# 执行命令# os system popen 不推荐使用 执行结果 1234567891011121314151617181920ntenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming&#x27;, &#x27;COMMONPROGRAMFILES&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMMONPROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)\\\\Common Files&#x27;, &#x27;COMMONPROGRAMW6432&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMPUTERNAME&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;COMSPEC&#x27;: &#x27;C:\\\\Windows\\\\system32\\\\cmd.exe&#x27;, &#x27;DRIVERDATA&#x27;: &#x27;C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData&#x27;, &#x27;HOMEDRIVE&#x27;: &#x27;C:&#x27;, &#x27;HOMEPATH&#x27;: &#x27;\\\\Users\\\\Windows&#x27;, &#x27;IDEA_INITIAL_DIRECTORY&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\Desktop&#x27;, &#x27;LOCALAPPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local&#x27;, &#x27;LOGONSERVER&#x27;: &#x27;\\\\\\\\DESKTOP-0R6DJK5&#x27;, &#x27;NUMBER_OF_PROCESSORS&#x27;: &#x27;4&#x27;, &#x27;ONEDRIVE&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;ONEDRIVECONSUMER&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;OS&#x27;: &#x27;Windows_NT&#x27;, &#x27;PATH&#x27;: &#x27;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\ odejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Scripts\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming\\ pm;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PATHEXT&#x27;: &#x27;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#x27;, &#x27;PROCESSOR_ARCHITECTURE&#x27;: &#x27;AMD64&#x27;, &#x27;PROCESSOR_IDENTIFIER&#x27;: &#x27;Intel64 Family 6 Model 78 Stepping 3, GenuineIntel&#x27;, &#x27;PROCESSOR_LEVEL&#x27;: &#x27;6&#x27;, &#x27;PROCESSOR_REVISION&#x27;: &#x27;4e03&#x27;, &#x27;PROGRAMDATA&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;PROGRAMFILES&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)&#x27;, &#x27;PROGRAMW6432&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PSMODULEPATH&#x27;: &#x27;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules&#x27;, &#x27;PUBLIC&#x27;: &#x27;C:\\\\Users\\\\Public&#x27;, &#x27;PYCHARM&#x27;: &#x27;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PYCHARM_DISPLAY_PORT&#x27;: &#x27;63342&#x27;, &#x27;PYCHARM_HOSTED&#x27;: &#x27;1&#x27;, &#x27;PYTHONIOENCODING&#x27;: &#x27;UTF-8&#x27;, &#x27;PYTHONPATH&#x27;: &#x27;D:\\\\opencv_study;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_matplotlib_backend;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_display&#x27;, &#x27;PYTHONUNBUFFERED&#x27;: &#x27;1&#x27;, &#x27;SESSIONNAME&#x27;: &#x27;Console&#x27;, &#x27;SYSTEMDRIVE&#x27;: &#x27;C:&#x27;, &#x27;SYSTEMROOT&#x27;: &#x27;C:\\\\Windows&#x27;, &#x27;TEMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;TMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;USERDOMAIN&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERDOMAIN_ROAMINGPROFILE&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERNAME&#x27;: &#x27;Windows&#x27;, &#x27;USERPROFILE&#x27;: &#x27;C:\\\\Users\\\\Windows&#x27;, &#x27;WINDIR&#x27;: &#x27;C:\\\\Windows&#x27;&#125;)\\;D:\\opencv_study(&#x27;D:\\\\opencv_study&#x27;, &#x27;main.py&#x27;)main.pyTrueTrue1697922899.98245931697807194.7697878986Process finished with exit code 0 python文件打开新的终端，并执行文件linux 环境在写Python程序的时候遇到需要打开一个新的终端(terminal)或者说命令行窗口进行监视的情况 12345import osos.system(&quot;gnome-terminal -e &#x27;ls&#x27;&quot;) # 窗口执行后关闭os.system(&quot;gnome-terminal -e &#x27;bash -c \\&quot;ls; exec bash\\&quot;&#x27;&quot;) # 窗口执行后不关闭# 其中 &#x27;ls&#x27; 部分即为所需执行的内容。 Windows环境1234import osos.system(&quot;start powershell.exe cmd /k &#x27;dir&#x27;&quot;)# 其中 &#x27;dir&#x27; 部分即为所需执行的内容","tags":["python"]},{"title":"opencv學習","path":"/2023/10/19/opencv學習/","content":"参考资料 https://www.bilibili.com/video/BV1ET4y127vd/?spm_id_from=333.999.0.0&amp;vd_source=755a0f899976f771c7923daed9448d48 https://opencv.apachecn.org/ opencv简介是什么？计算机视觉开源软件库 numpy opencv-python的安装打开cmd输入 123pip install opencv-pythonpip install opencv-contrib-python 开梯子下载更快 测试代码 123456import cv2# 读一个图片并进行显示(图片路径需自己指定)lena=cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, lena) # 打开新窗口，窗口名为image,显示Lenacv2.waitKey(0) opencv模块opencv其中core、highgui、imgproc是最基础的模块，该课程主要是围绕这几个模块展开的，分别介绍如下: core模块实现了最核心的数据结构及其基本运算，如绘图函数、数组操作相关函数等 highgui模块实现了视频与图像的读取、显示、存储等接口。 imgproc模块实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、闻值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。 其他 features2d模块用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。obidetect模块实现了一些目标检测的功能，经典的基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification (级联分类)和Latent SVM等。 stitching模块实现了图像拼接功能。 FLANN模块 (Fast Library for Approximate Nearest Neighbors)，包含快速近似最近搜索FLANN和聚类Clustering算法。 ml模块机器学习模块 (SVM，决策树，Boosting等等) photo模块包含图像修复和图像去噪两部分。 video模块针对视频处理，如背景分离，前景检测、对象跟踪等。 calib3d模块即Calibration (校准)3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。G-API模块包含超高效的图像处理pipeline引擎 图像的基础操作 掌握图像的读取和保存方法 能够使用OpenCV在图像上绘制几何图形 能够访问图像的像素 能够获取图像的属性，并进行通道的分离和合并0 能够实现颜色空间的变换 读取图像1cv.imread(&quot;路径&quot;) cv.IMREAD*COLOR:以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。 cv.IMREAD*GRAYSCALE: 以灰度模式加载图像 Cv.IMREAD UNCHANGED: 包括alpha通道的加载图像模式。可以使用1、0或者-1来替代上面三个标志12345678import numpy as npimport cv2#以灰度图的形式读取图像img = cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, img)cv2.waitKey(0) 注意:如果加载的路径有错误，不会报错，会返回一个None值 显示图像1cv.imshow(&quot;窗口名&quot;， 图片) 注意:在调用显示图像的API后，要调用cv.waitKey()&#x2F;&#x2F;等待键盘输入 给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来。waitkey(0)，永远等待另外我们也可使用matplotlib对图像进行展示。 保存图像1cv.imwrite(&quot;文件名&quot;， 图片变量) 总结： 12345678910import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt#读取图像img = cv.imread(&#x27;1.png&#x27;,1)# 利用opencv展示图像cv.imshow( &#x27; image&#x27;, img)k = cv.waitKey(0)# 3 保存图像cv.imwrite( &#x27;messigray.png&#x27;,img) course_1code123456789101112131415161718192021222324252627# 学习了基本操作，imread(), imwrite()等import cv2 as cv# 获取摄像头cap = cv.VideoCapture(0)# set the height(3) and width(4) of the windows# windows系统下，微软surface的系统摄像头，该设置失效，原因未明# 外置摄像头OKcap.set(3, 640)cap.set(4, 480)# set brightness# 但好像也没什么用cap.set(10, 0.00001)while True: success, img = cap.read() cv.imshow(&quot;camera&quot;, img) if cv.waitKey(1) == ord(&#x27;Q&#x27;) or cv.waitKey(1) == 27: # 当所有事完成，释放 VideoCapture 对象 cap.release() cv.destroyAllWindows() break 详解1234cap = cv.VideoCapture(2)VideoCapture()中参数是0，表示打开笔记本的内置摄像头，参数是视频文件路径，打开方式如下：cap = cv2.VideoCapture(“../test.avi”) 12success, img = cap.read()cap.read()按帧读取视频，ret,frame是获cap.read()方法的两个返回值。 其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就为False。frame就是每一帧的图像，是个三维矩阵。 1234waitKey（）方法本身表示等待键盘输入，参数是1，表示延时1ms切换到下一帧图像。对于视频而言；参数为0，如cv2.waitKey(0)只显示当前帧图像，相当于视频暂停；参数过大如cv2.waitKey(1000)，会因为延时过久而卡顿感觉到卡顿。c得到的是键盘输入的ASCII码，esc键对应的ASCII码是27，即当按esc键是if条件句成立 course_2code1234567891011121314151617181920212223242526272829303132333435import cv2 as cvimport numpy as npaaa = np.ones((5, 5), np.uint8)# cv.imread(&quot;路径&quot;， 参数)，参数不传，默认参数1img = cv.imread(&quot;img/1 (1).jpg&quot;)# cv2.namedWindow(‘窗口标题’,默认参数) 创建新窗口cv.namedWindow(&#x27;Local Camera&#x27;, 0)# 设置显示的窗口大小为500,500，建议大于等于摄像头分辨率cv.resizeWindow(&quot;Local Camera&quot;, 300, 300)cv.imshow(&quot;Local Camera&quot;, img)# 灰度图片imgGray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)cv.imshow(&quot;show imgGray&quot;, imgGray)# 高斯模糊imgBlur = cv.GaussianBlur(img, (7, 7), 0)cv.imshow(&quot;show imgBlur&quot;, imgBlur)# 边缘检测imgCanny = cv.Canny(img, 150, 200)cv.imshow(&quot;show imgCanny&quot;, imgCanny)# 膨胀imgDilation = cv.dilate(imgCanny, aaa, iterations=1)cv.imshow(&quot;show imgDilation&quot;, imgDilation)# 腐蚀imgErode = cv.erode(imgDilation, aaa, iterations=1)cv.imshow(&quot;show imgErode&quot;, imgErode)cv.waitKey(0) course_3学习图像像素查看，图片大小调整，图片裁剪 opencv的X,Y的位置piM2Zzd.png code12345678910111213141516171819202122232425import cv2 as cvimport numpy as npimg = cv.imread(&quot;img/1 (1).jpg&quot;)print(img.shape)print(img.shape[0])# 打印出(1526, 1080, 3)# 打印出的分别是，高，宽，BGR# 图像大小调整，参数为宽，高a = int(img.shape[1]*0.3)b = int(img.shape[0]*0.3)imgResize = cv.resize(img, (a, b))print(imgResize.shape)# 图像裁剪 高与宽imgCropped = img[0:400, 200:400]cv.imshow(&quot;LOCAL img&quot;, img)cv.imshow(&quot;LOCAL imgResize&quot;, imgResize)cv.imshow(&quot;LOCAL imgCropped&quot;, imgCropped)cv.waitKey(0) piMRwjA.png course_4 绘画12345678910111213141516171819202122import cv2 as cvimport numpy as np# 0为黑，1为白img = np.zeros((400, 400))img1 = np.zeros((400, 400, 3))imgBlue = img1.copy() # 令imgBlub = img，则会报错，img为二维数组，只有黑白imgBlue[:] = 255, 0, 0# 划线，参数1,图片，参数2，起始点,参数3，终止点，参数4，color 参数5，厚度cv.line(img1, (0, 0), (400, 250), (255, 255, 255), 1)# 画矩形，参数配置同上,参数5也可用cv.FILLED,填充cv.rectangle(img1, (0, 0), (400, 200), (255, 255, 0), 2)# 画圆cv.circle(img1, (200, 70), 30, (255, 255, 100), cv.FILLED)cv.imshow(&quot;img&quot;, img)cv.imshow(&quot;img2&quot;, img1)cv.imshow(&quot;imgBlue&quot;, imgBlue)cv.waitKey(0) course_5 透视变换12345678910111213141516import cv2 as cvimport numpy as np# 矩阵变换width, height = 250, 350img = cv.imread(&quot;img/1 (15).png&quot;)pts1 = np.float32([[108, 240], [276, 209], [150, 491], [342, 451]])pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])matrix = cv.getPerspectiveTransform(pts1, pts2) # 获得透视关系out_img = cv.warpPerspective(img, matrix, (width, height)) # 透视cv.imshow(&quot;local img&quot;, img)cv.imshow(&quot;out_img img&quot;, out_img)cv.waitKey(0) piJGDu8.png 解析cv2.getPerspectiveTransform()是一个OpenCV函数，用于获取透视变换矩阵。它需要两个参数，分别是源图像中待测矩形的四点坐标和目标图像中矩形的四点坐标。它返回一个3x3的变换矩阵，可以用于cv2.warpPerspective()函数进行透视变换。 1234567891011121314import cv2import numpy as np# 定义源图像中待测矩形的四点坐标pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])# 定义目标图像中矩形的四点坐标pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])# 获取透视变换矩阵M = cv2.getPerspectiveTransform(pts1, pts2)# 输出变换矩阵print(M) 输出为 123[[ 8.24482681e-01 -1.02318154e-01 -3.33674687e+01] [ 1.18180922e-01 9.43895645e-01 1.17818491e+01] [ 1.65498408e-04 -1.69338403e-04 1.00000000e+00]] warpPerspective()函数主要作用：对图像进行透视变换，就是变形cv.warpPerspective是OpenCV中的一个函数，主要用于对图像进行透视变换。它可以将原始图像中的任意四边形区域转换为目标图像中的矩形区域，从而实现图像的透视变换。该函数的语法如下： 1dst = cv.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) 其中，参数含义如下：src：输入图像，可以是8位无符号整数、32位浮点数或16位有符号整数。M：3x3变换矩阵。dsize：输出图像的大小。dst：输出图像，与输入图像具有相同的数据类型和通道数。flags：插值方法的标志，可以是cv2.INTER_NEAREST、cv2.INTER_LINEAR、cv2.INTER_CUBIC、cv2.INTER_AREA、cv2.INTER_LANCZOS4等。borderMode：边界填充模式，可以是cv2.BORDER_CONSTANT、cv2.BORDER_REPLICATE、cv2.BORDER_REFLECT、cv2.BORDER_WRAP等.borderValue：边界填充值。","tags":["opencv"]},{"title":"linux系统学习","path":"/2023/10/10/linux系统学习/","content":"计算机硬件结构冯 诺依曼结构 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 其他主流计算机硬件结构 哈佛体系 计算机之父 冯 诺依曼图灵 计算机硬件组成输入设备输出设备存储器RAMRAM(random access memory) 即随机存储内存 速度快，容量小 掉电易失 逻辑IO ROMROM (Read-Onboy Memory) 即只读内存硬盘 容量大，速度相对较慢 长久保存 物理10 运算器、控制器网络连接 ip地址 子网掩码 默认网关 DNS ip地址IPADDRip地址 &#x3D; 网络地址+主机地址ip地址是一个4*8bit由0&#x2F;1组成的字符串（ip4协议） 子网掩码","tags":["linux"]},{"title":"hexo部署到github图片不显示的解决","path":"/2023/10/03/hexo部署到github图片不显示的解决/","content":"前言hexo直接部署到github时，文章的图片并不显示，而免费图床又有跑路风险。于是为了我的图片安全，我决定寻求解决方法，网上关于hexo直接部署到github是有解决方法的，但是，大部分都是无效的！！下面是我整理出来的行之有效的解决方法 即将寄掉的图床 有哪些免费又好用的图床网站? - 程序员蜗牛的回答 - 知乎https://www.zhihu.com/question/337669216/answer/1699620048 参考资料 https://zhuanlan.zhihu.com/p/542101567 步骤1.安装插件来到自己的博客本地目录，右键打开git bash,输入以下命令 1npm install hexo-asset-image --save 2.修改两个文件由于插件较早，还有bug,还要修改一些文件 进入你博客的根目录，然后下面顺序找到index.js:node_modules –&gt; hexo-asset-image –&gt; index.js 用VS Code 或者 记事本打开 index.js 在第 58 行，可以找到这么一行代码： $(this).attr(‘src’, config.root + link + src); 把这一行代码改成下面这样 $(this).attr(‘src’, src); 保存文件 另外还要先把 _config.yml中的 post_asset_folder: false 改成 post_asset_folder: true (默认是false，如果你没有修改过，那请去修改) 3.插入图片使用 hexo new “myfile” 此时会在你的md同级目录下创建与myfile同名的文件夹，把要导入的图片放在这个文件夹里在md文件需要的地方插入图片即可 12345这种在本地和网站都可显示&#123;% image ./myfile/xxx.png %&#125; 这种在网站可显示，本地不可显示&#123;% image xxx.png %&#125; over","tags":["hexo"]},{"title":"arduino的系统学习","path":"/2023/09/29/arduino的系统学习/","content":"我还是决定系统学一下arduino，虽然系统学，但仍是速成，由于碰到一些事情我意识到自己还不够努力，就从arduino开始吧 arduino IDE下载 www.arduino.cc arduino uno引脚图引脚 Arduino UNO是基于ATmega328P的Arduino开发板。它有14个数字输入&#x2F;输出引脚（其中6个可用于PWM输出）、6个模拟输入引脚，一个16 MHz的晶体振荡器，一个USB接口，一个DC接口，一个ICSP接口，一个复位按钮。它包含了微控制器所需的一切，你只用简单地把它连接到计算机的USB接口，或者使用AC-DC适配器，再或者用电池，就可以驱动它。 存储空间ATmega328 有32KB Flash存储空间（其中0.5KB被用于存储bootloader），2KB 的SRAM和1KB 的EEPROM。可以使用官方提供的EEPROM库读写EEPROM空间。 输入输出Arduino Uno有14个数字输入输出引脚，可使用 pinMode()、digitalWrite() 和 digitalRead() 控制。其中一些带有特殊功能，这些引脚如下 Serial0（RX）、1（TX），被用于接收和发送串口数据。这两个引脚通过连接到ATmega16u2来与计算机进行串口通信。 外部中断2、3，可以输入外部中断信号。中断有四种触发模式：低电平触发、电平改变触发、上升沿触发、下降沿触发。 PWM输出：3、5、6、9、10、11，可用于输出8-bit PWM波。对应函数 analogWrite() 。 SPI：10（SS）、11（MOSI）、12（MISO）、13（SCK），可用于SPI通信。可以使用官方提供的SPI库操纵。 L-LED：13。13号引脚连接了一个LED，当引脚输出高电平时打开LED，当引脚输出低电平时关闭LED。 TWI：A4（SDA）、A5（SCL）和TWI接口，可用于TWI通信，兼容I²C通信。可以使用官方提供的Wire库操纵。 点亮一个LED灯点灯大师，闪亮登场LED灯正负两端会有2v的电压差 pinMode(引脚号，状态) 设置引脚模式 输出(OUTPUT) 输入(INPUT) 输入上拉模式(INPUT_PULLUP) digitalWrite(引脚号,状态); 引脚输出状态 HIGH(高电平) LOW(低电平) 上拉电阻arduino开发板上拉电阻10K 引脚悬空引脚设置成INPUT却没有加任何电路，引脚检测状态不定（0&#x2F;1） 123456789//点亮二号引脚void setup() &#123; pinMode(2,OUTPUT);&#125;void loop() &#123; digitalWrite(2,HIGH);&#125; 串口通信digitalRead(引脚号)读取某个引脚状态，常与pinMode(引脚号,INOUT)搭配使用 Serial.begin(9600);串口初始化设置9600为常用波特率 Serial.println(打印内容);在电脑的串口监视器上输出相应内容 delay(时间)延时函数，单位为ms 12345678910void setup() &#123; pinMode(2,INPUT); Serial.begin(9600);&#125;void loop() &#123; int buttonState = digitalRead(2); Serial.println(buttonState); delay(1);&#125; 引脚悬空 模拟输出标有~的数字引脚可输出PWM信号 analogWrite(Pin,bringtness)模拟输出，Pin,引脚号; brigngness为亮度范围0~255,输出的为Pwm信号，PWM信号的频率大约为490Hz.在Arduino UNO控制器中，5号引脚和6号引脚的PWM频率为980Hz。 呼吸灯（周期未测）12345678910111213141516void setup() &#123; Serial.begin(9600);&#125;void loop() &#123;for (int brightness = 0;brightness &lt;= 255;brightness+=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;for (int brightness = 255;brightness &gt;= 0;brightness-=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;&#125; 模拟输入电位器电位器 ananaloRead(Pin)读取范围0-5v,返回0~1023的数值，读入的最大频率为10 000次，引脚悬空状态读的数值不定 变量B &#x3D; map(变量A,A_min,A_max,B_min,B_max)将变量A等比映射到变量B 1234567891011void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; int a = map(analogRead(A0),0,1023,0,255); Serial.println(a); delay(10);&#125; 电机驱动电机种类 直流电机(DC) 交流电机(AC) 交直流两用电机(Universal) 使用arduino的引脚直接驱动直流电机简直蠢爆了，引脚输出电流不够,pwm给小了根本不动，当然，这里只是验证analogWrite是PWM信号，周期490Hz 12345678void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; analogWrite(9,200);&#125; 引脚直接驱动电机 舵机驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 SG90舵机 12345678910111213141516171819202122232425262728293031323334353637383940/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 舵机驱动 步进电机驱动步进电机优点 精准控制电机输出轴角度 低速运行时扭矩大 开环控制&#x2F;性价比高 步进电机的分类 单极性步进电机 5-6条引脚，相对输出扭矩低，控制简单 双极性步进电机 4条引脚，相对输出扭矩高，控制复杂 步进电机的参数 额定电流 额定电压 定位转矩 不通电 保持转矩 通电 相数 可独立通电的定子电磁线圈数步进电机详解 http://t.csdnimg.cn/TkxCb","tags":["arduino"]},{"title":"gazebo的学习与应用","path":"/2023/09/26/gazebo的学习与应用/","content":"学习目标与任务 Gazebo和环境模型设计 机器人模型设计 为模型上装备传感器与执行器 https://gazebosim.org/docs","tags":["ros"]},{"title":"基于古月居的ros入门","path":"/2023/09/21/基于古月居的ros入门/","content":"前言由于前段时间的学习总结的习惯不好，决定新开一栏用于ros基础学习。有一说一，通过和学长的进度比较，总感觉自己是个废物。 虚拟机的安装不要装机械盘，运行慢。使用VMwareubantu系统18 linux基本命令行123456789101112cdlsmvrm -rcppwdmkdirtouchshutdown -h nowrebootsudo 基本命令行12sudo apt-get update //更新源source ~/catkin_ws/devel/setup.bash //刷新环境变量 前置安装123456789//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim//ros安装wget http://fishros.com/install -O fishros &amp;&amp; . fishros ros的核心概念节点（node）与节点管理器（ros master）节点名称唯一 话题(topic)与服务(serve) 话题：单向 发布者 订阅者 消息(massage):话题的数据由.msg文件定义 服务：双向 客户端 服务端 .srv文件定义命名请求应答数据 参数(parameter)—全局共享字典适合静态，非二进制的配置参数 文件系统 功能包（package） ：含节点源码，配置文件，数据定义 功能包清单： 作者信息，许可信息，依赖选项 元功能包：组织多个同一目的的功能包 ros命令行工具123456rostopicrosservicerosnoderosparamrosmsgrossrv 小海龟123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 工具123456789rqt_graph //节点可视化rosnode //显示节点rostopic //话题 pubrosmsgrosservice //服务 callrosbag record -a -O cmd_record //话题记录 cmd_record位保存文件名，默认hom目录下rosbag play cmd_record.bag //话题复现 ros的文件结构 1234567891011121314151617181920212223242526272829303132WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 创建工作空间123456789101112131415//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_makecatkin_make install //可要可不要//设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash 问题：我需要在原有的ROS工程基础之上，新建一个ROS功能包。我直接复制了其他目录下原有的一个包，进行修改。然后问题来了：catkin_make后竟然没有反应。甚至没有检测到我新改写的cmake 解决：ros允许多个工作空间使用相同功能包，但多个工作空间source不要放在脚本里，手动敲，否则会被覆盖,在catkin_make之前source一下，之后再source一下。而且要多次执行，如下。注意要先开下roscore，py文件要给其可执行权限. 123456//将文件复制过来后，在工作空间目录下打开终端source ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bash 脚本文件的source只在新的终端开启时才运行 发布者与订阅者以海龟为例 python文件要记得给可执行权限 发布者123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher():\t# ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True)\t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)\t#设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 订阅者123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber():\t# ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True)\t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)\t# 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 消息的自定义定义msg文件在功能包的src同级目录下创建msg文件夹12345678910// 举例，该文件名为Person.msgstring nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 launch文件使用 launch 文件，可以一次性启动多个 ROS 节点launch文件自动启动ROS Master 123456789101112131415161718192021&lt;!-- 包名 节点名称 自定义节点名 --&gt;&lt;!-- 注释 --&gt;&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt; &lt;!-- 参数设置 --&gt; &lt;param name=&quot;output_feame&quot; value=&quot;odom&quot;/&gt; &lt;!-- name:参数名称，value 参数值 --&gt; &lt;rosparam= file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!-- 重映射remap --&gt; &lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt; &lt;!-- from:原名 to:映射后的名字 --&gt; &lt;!-- 嵌套include --&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 客户端与服务端客户端 rosservice call &#x2F;clear “{}” 参数的使用parameter Server 全局变量存储空间 123456789101112// 列出当前有多个参数rosparam list// 显示某个参数值rosparam get param_key// 设置某个参数值rosparam set param_key param_value//保存参数到文件rosparam dump file_name// 从文件读取参数rosparam load file_anme// 删除参数rosparam delete param_key yaml 参数文件在程序里实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config():\t# ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True)\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;);\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() TF坐标管理系统tf功能包，默认10秒 实现机制 广播TF变换 监听TF变换12345678//安装功能包sudo apt-get install ros-melodic-turtle-tf//启动节点roslaunch turtle tfturtle tf demo.launch//turtles键盘控制节点rosrun turtlesim turtle teleop_key//保存tf tree为 pdf 至当前目录rosrun tf view frames tf工具 命令行工具rosrun tf tf_echo turtle1 turtle2 可视化工具 rosrun rviz rviz -d rospack find turtle tf &#x2F;rviz&#x2F;turtle rviz.rviz tf坐标的广播与监听单词释义quaternion 四元数radian 弧度degree 角度 常用可视化工具QT工具箱 日志输出rqt_console 计算图ret_graph 数据绘图rqt_plot 图像渲染rqt_image_view rviz gazebo 进阶 控制与仿真 gazebo + ros +ros_control","tags":["ros"]},{"title":"stc驱动TM1608","path":"/2023/09/16/stc驱动TM1608/","content":"tm1638.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef _TM1638_H#define _TM1638_H#include &lt;STC32G.H&gt;//TM1638模块引脚定义sbit DIO=P1^3; //数据线sbit CLK=P1^0; //时钟线sbit STB=P1^1; //片选线//共阴数码管显示代码unsigned char code dis[11]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x00&#125;; unsigned char while_one[8]=&#123;0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce&#125;;void TM1638_Write(unsigned char Data) //写数据函数&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; CLK=0; DIO=Data&amp;0x01; Data&gt;&gt;=1; CLK=1;\t&#125;&#125;void Write_Command(unsigned char Command) //发送命令&#123;\tSTB=0;\tTM1638_Write(Command);\tSTB=1;&#125;void Write_Data(unsigned char add,unsigned char Data) //指定地址写入数据&#123;\tSTB=0;\tTM1638_Write(0x00|add);\tTM1638_Write(Data);\tSTB=1;&#125;//TM1638初始化函数void init_TM1638(void)&#123;\tunsigned char i;\tWrite_Command(0x8F); Write_Command(0x40); //采用地址自动加1\tSTB=0; TM1638_Write(0xc0); //设置起始地址\tfor(i=0;i&lt;16;i++) //传送16个字节的数据 TM1638_Write(0x00);\tSTB=1;&#125;#endif tm1638.c 123456789101112131415161718192021#include &lt;STC32G.H&gt;#include &quot;tm1638.h&quot;void TMmain(void)&#123; unsigned char i;\tP0=0xff;P2=0x80;P2&amp;=0x1f; P0=0;P2=0xa0;P2&amp;=0x1f; //关闭单片机LED、蜂鸣器、继电器，主要是刺眼。。。 init_TM1638(); //初始化TM1638\tfor(i=0;i&lt;8;i++)\tWrite_Data(i,dis[10]); //初始化寄存器\twhile(1)\t&#123; Write_Data(while_one[0],dis[6]); //选中GRID1，令第一位数码管显示0\t&#125;&#125;","tags":["单片机"]},{"title":"stc32学习","path":"/2023/09/14/stc32学习/","content":"时隔三月，再摸单片机，这一次我要把遗忘的全部拿回来 STC32介绍 STC I&#x2F;O口工作模式 除了P3.0和P3.1（准双向口）外，其他默认高阻输入模式准双向口和推挽输出模式默认为高电平 define和typedef12typedf unsigned char u8;给已存在的数据类型起别名 WTST程序读取等待控制寄存器，上电默认为70-255 volatile设置变量，防止优化 预编译处理12345678910//主要命令有#include#ifndef //如果宏未定义则执行#define //定义宏#endif //结束有if的定义#elif#undef // 取消已定义的宏#line#program#error 模块化编程思想 移位法点亮LED 1234567while(1)&#123; for(i = 0;i &lt; 8; i++) &#123; P2 = ~(0x01 &lt;&lt; i); delayms(500); &#125;&#125; 上拉电阻和下拉电阻所有IO口都配置了一个4.1K的上拉电阻和10K的下拉电阻都是8位寄存器上拉电阻控制寄存器：PxPU上拉电阻控制寄存器：PxPD(x &#x3D;0,1,2,3,4,5,6,7) 123456789P7M1 = 0xFF;P7M0 = 0x00; //高阻输入模式EAXFR = 1; //使能XFR,特殊寄存器，设置使之能访问while(1)&#123; P7PU = 0x01; //加上拉电阻等于准双向口模式 delayms(1000); P&amp;PD = 0x00; delayms(1000);&#125; 自适应delayms()函数12345678#define MAIN_Fose = 35000000 //设置主频void delayms(int ms)&#123; int i; do&#123; i = MAIN_Fose/6000; while(i--); &#125;while(--ms);&#125; 特殊功能寄存器（SFR，XFR）地址范围0x7E0000-0x7EFFF如需访问扩展寄存器，需先设置SFR使能寄存器CKCON 外部数据总线时钟控制寄存器CKCON &#x3D; 0x00;(上电默认为7，建议设为0) 74HC595独立按键定时器与计数器5个24位定时器&#x2F;计数器（八位预分频+16位计数）","tags":["单片机"]},{"title":"社团成员基本学习路线及其介绍","path":"/2023/09/05/社团成员基本学习路线及其介绍/","content":"本文档用于告知新生社员基本的学习路线，学习方向。该文档同步发布在我的个人博客(liwuyou.github.io)以及3D打印社网站(cumtb.club)上个人意见，仅供参考如果对学习路线有疑问或者不了解的地方，请联系社长或管理员 学习路线语言类 c&#x2F;c++ python English 单片机类 arduino –&gt; esp32 51单片机 –&gt; stm32 树莓派&#x2F;香橙派 硬件类 电脑装配及结构认识 solidworks基本使用 基本元器件使用及选型 原理图及pcb板的绘制 元件焊接工艺 软件类 github的使用 chatgpt的使用 基本网络知识及电脑工具使用 ros基本了解 linux学习 神经网络学习 个人博客搭建 具体介绍请注意学习路线里面的，并不是所有内容都要学。 首先呢，语言类方面，我们要学习一门编程语言，如果你想走嵌入式开发c是必选的，如果你想走更偏软件一点的机器学习，人工智能的路线，推荐学习python，如果更偏向于算法，对计算机更加细致入微的调控请选择C++。北矿的我们，大一上学期学的是python，但是课程很水，两节课就可以讲完所有的python基本语法，课程简单，基本不会挂科。大一下学期学的是C语言，蛮重要的，会考试，分数占比大，容易挂科。推荐入门，语言使用c，理由如下，下学期要学C语言，提前预习，可获得更高分数，或者获得更多的空余时间。然后尽量把英语学好，特别是在外网的时候，英语就很重要了，当然不会，也没有关系。用翻译软件也能解决，但是翻译软件并不能适用于所有场景，所以英语还是尽量学好一点 而在单片机类中，什么是单片机，请自行百度，了解什么是单片机，单片机的常见类型。为什么要学习单片机呢？单片机是嵌入式开发学习的基本环节，学会了使用单片机，我们可以设计一些具有一些实用价值的东西，如智能门锁，烟雾报警器，联网天气显示时钟等。我们目前使用的单片机类型有很多，而最简单的最好入门的最容易上手的是arduino，arduino开发套件，淘宝上买的话，大概100多块钱，闲鱼上二手更便宜。Arduino，开发简单，开源库多，资料较多。arduino学完下一步就可以使用，arduino的开发环境，开发esp32，Esp 32是一款性能更加强大，具有联网和蓝牙功能的单片机，价格低廉。如果不从arduino入手的话，也可以从51单片机进行入门，51单片机是stm32单片机的前置课程，直接上手stm 32难度较大，学完51更容易上手。Stm32是当前使用规模最大的单片机类型之一，功能强大，性能优越，能够完成很多复杂的工作，如果方向是嵌入式的话，很难不接触到stm 32这款单片机。而且stm 32也是大学生毕业设计的首选单片机之一。然后就是树莓派和香橙派以及其他什么派，从某种意义上来讲，这些派应该不属于单片机类型，他们可以连接屏幕，充当电脑，甚至安装WINDOWS系统使用。当然了，他们性能没有电脑这么强。一般他们都安装Linux系统进行开发，充当上位机使用。如自动导航小车的上位机。性能十分强大，价格也昂贵。 而硬件类方向，如果你是传统工科专业，可能不可避免要接触到一些元器件的选型，和PCB板原理图的绘制。简单来说就是做一块完整的，能够正常使用的电路板。再介绍一下solidwords，具体使用请参照，零基础小白3d打印基本入门，这篇文章。这是一款功能强大的软件，可以用于3d建模，然后将建模好的文件导出进行3d打印。他是我们3d打印社成员，必须要掌握的一款软件。而电脑的装配及结构认识，如果你有兴趣的话，我们可以和你一起组装电脑，当一名图吧垃圾佬。我们实验室的电脑都是自己组装的，自己在网上淘CPU，显卡，机箱等 而在软件类方向，我们首先第一步是科学上网，这一步自行领悟。然后使用github，github是开源社区开源社区里面有很多开源的项目和代码，计算机类必备。然后还要学习一些基本的电脑工具软件，如资源管理器，powershell等Linux系统是我们开发的常用系统，特别是在机器人领域， 机器人开发平台ros，就是在Linux系统上开发的，像很多服务器，都搭载在Linux系统上。Linux系统相对于WINDOWS系统具有轻量化，稳定性的优点。十分建议学习。如果你python学的好的话，还可以进阶学习神经网络的相关知识，如视觉识别相关的open CV,yolo等 最后，对学习路线进行一下小小的总结。以下有几种路线以供选择，难度依次增大注意难度与实用并不相关。 最快最轻量的路线 语言类的c，硬件类的soildwords，单片机类的arduino，esp32 稍微复杂一点 语言类的python，c，硬件类的soildwords，单片机类的51，stm32 再复杂一点 语言类的python，c，硬件类的，pcb绘制，solidwords，单片机类的，arduino，esp32，stm32，软件类的linux开发 而第一学期，新生适宜参加的一些比赛有，校巡线车比赛，蓝桥杯比赛 最后，感谢你看到这里，如果内容有什么错误，请及时跟我们联系，如果有什么想法，可以和我们交流。谢谢","tags":["社团"]},{"title":"python study","path":"/2023/08/10/python-study/","content":"python规范 结尾空一行 导入库空两行 注释# 空一格 Python库的安装1pip install 库名 Python的导包方式12345678910111213# 1.import 常规导入，直接导入整个包的所有的功能函数##eg# 2.import多个导入，导入多个包的所有功能函数。##eg# 3.from … import …导入整个包的部分功能函数。##eg# 4.当然也可以通过from … import * 这个也是直接导入包的所有功能。相当于import … 重要的，在实际的应用中用得也是比较多的，我们自定义我们自己写的功能包。第一：在test_package文件夹中创建_init_.py文件，里边什么都不需要编辑。第二：在代码中把test_package的文件的路径加入到python解释器可以搜索到的路径列表中，这里就用到了python的包sys模块。下边是运行过一次的目录结构：pyc文件是py文件编译后生成的字节码文件，不需要自己创建，在你第一次成功导入包并运行成功之后会自动生成。 自定义导包 https://blog.csdn.net/weixin_45577864/article/details/121714956?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-121714956.nonecase&amp;spm=1018.2226.3001.4187","tags":["python"]},{"title":"links","path":"/2023/07/30/links/","content":"图标 介绍 网址 triority’s blog https://triority.cn/ 天鹅绒房间 https://qwqpap.xyz/ 北矿3D打印社 https://cumtb.club/"},{"title":"hexo一些问题的解决","path":"/2023/07/30/hexo一些问题的解决/","content":"hexo部署到github的报错解决报错如下 1234567891011fatal: unable to access &#x27;https://github.com/liwuyou/liwuyou.github.io.git/&#x27;: Failed to connect to github.com port 443 after 21100 ms: Couldn&#x27;t connect to serverFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (D:\\blog\\wj ode_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:514:28) at cp.emit (D:\\blog\\wj ode_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal/child_process:291:12) 为什么出现这个问题？网络代理问题或者网速不好（几率小） 如何解决？打开_config.yml找到 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: main repo改为 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: main 其中yourname改为你自己的github用户名 网络其他热门解决方法","tags":["hexo"]},{"title":"arduino小项目2——电压表","path":"/2023/07/30/arduino小项目2——电压表/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕，小按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V; void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; float a = Voltage_detect(); displayMenu(a);&#125; //oled屏幕显示void displayMenu(float a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); u8g2.print(&quot;Voltage, (0-5v)&quot;); // 显示电压表... u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.setCursor(20, 34); u8g2.println(a); u8g2.sendBuffer();&#125; //检测并转化为0-5vfloat Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); //读取io口模拟值 float Voltage = analogdate*5.0/1023.0; //转化 //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); //串口打印 &#125; else Serial.println(Voltage); return Voltage; //返回值&#125; 本来想弄万用表来着，emmp,放弃了,没写完，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int gear = 0; // 万用表状态 0.菜单；1.电压表；2.电流表；3.电阻表int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V;int R_I=220; // 电流表状态，电阻为220欧姆 void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; double a = Voltage_detect(); switch1(); displayMenu(a); int analogdate = analogRead(A0); &#125; void switch1() &#123; int key = digitalRead(2); // 第一次判断 if (key == 0) &#123; // 延时20ms 消除按键抖动 delay(20); // 第二次判断 if (key == 0) &#123; gear++; // 状态++ if (gear &gt; 3) &#123; gear = 0; // 循环到第一个菜单状态 &#125; &#125; // 等待按键被松开 while (!digitalRead(2)) &#123; // 等待按键松开 &#125; &#125;&#125; void displayMenu(double a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); switch (gear) &#123; case 0: //u8g2.print(&quot;Menu&quot;); // 显示菜单选项... face(); break; case 1: u8g2.print(&quot;Voltage&quot;); // 显示电压表... u8g2.setCursor(20, 34); u8g2.println(a); break; case 2: u8g2.print(&quot;Current&quot;); // 显示电流表... break; case 3: u8g2.print(&quot;Resistance&quot;); // 显示电阻表... break; &#125; u8g2.sendBuffer();&#125; void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; float Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); float Voltage = analogdate*5.0/1023.0; //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); &#125; else Serial.println(Voltage); return Voltage;&#125;","tags":["arduino"]},{"title":"arduino小项目1——小时钟","path":"/2023/07/30/arduino小项目1——小时钟/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕 接线图，文字描述。单片机上的A4接小屏幕上的SDA，A5接SCL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;MsTimer2.h&gt;#include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int year = 2020, month = 1, day = 1, hour = 0, minute = 0, second = 0; void onTimer() &#123; second++; if (second &gt;= 60) &#123; second = 0; minute++; if (minute &gt;= 60) &#123; minute = 0; hour++; if (hour &gt;= 24) &#123; hour = 0; &#125; &#125; &#125;&#125; void setup() &#123; Serial.begin(9600); u8g2.begin(); u8g2.clearBuffer(); MsTimer2::set(1000, onTimer); // 中断时间为1秒 MsTimer2::start(); // 启动定时器&#125; void loop() &#123; displayTime();&#125; void displayTime() &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.drawStr(0, 15, &quot;TIME:&quot;); u8g2.setFont(u8g2_font_ncenB12_tr); char strTemp[12]; sprintf(strTemp, &quot; %d.%.2d.%.2d&quot;, year, month, day); u8g2.drawStr(35, 15, strTemp); u8g2.setFont(u8g2_font_ncenB14_tr); sprintf(strTemp, &quot;%.2d.%.2d.%.2d&quot;, hour, minute, second); u8g2.drawStr(25, 45, strTemp); u8g2.sendBuffer();&#125;","tags":["arduino"]},{"title":"markdown基本介绍与语法","path":"/2023/07/26/markdown基本介绍与语法/","content":"markdown是什么？Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等 我为什么使用markdown写个人博客需要，且markdown使用简单，b站搜索十分钟学会，word无法完成个人博客的书写.markdown和word可相互转化,但效果不好，排版问题较大。markdown无法实现精细排版要求。 在线编译器网址https://markdown.com.cn/editor/在线转化器网址https://www.easeconvert.com/markdown-to-word/ 基本语法12345678910111213141516171819202122232425262728293031323334353637383940——————标题——————# 一级标题## 二级标题### 三级标题...###### 六级标题——————字体———————**这个是粗体***这个是斜体****这个是粗体加斜体***~~这里想用删除线~~--- 分割线——————列表———————无序列表的使用，在符号`-`后加空格使用有序列表的使用，在数字及符号`.`后加空格后输入内容——————图片———————使用符号&gt;&gt; 引用内容——————表格———————可以使用冒号来定义表格的对齐方式，如下：| 姓名 | 年龄 | 工作 || :----- | :--: | -------: || 小可爱 | 18 | 吃可爱多 || 小小勇敢 | 20 | 爬棵勇敢树 || 小小小机智 | 22 | 看一本机智书 |——————链接———————[描述](链接)——————图片———————![描述](链接)——————代码———————```语言代码块``` (占位，不管) 笔记over","tags":["markdown"]},{"title":"ros车基本学习（基于讯飞车）","path":"/2023/07/24/ros车基本学习/","content":"ros是什么（个人理解）ros是个机器人操作系统，可以在上面实现对机器人的操作，好比一个工作台，别人给你造好，直接使用上面的工具方便造自己的作品. 我为什么学ROS竞赛需要,智能车讯飞比赛及人工智能比赛甚至电赛控制类赛题也能用到 节系统是乌班图18的系统。 123456//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim 代码运行实例（c++） 123456789101112//终端输入，在主目录下创造一个test的文件夹。mkdir test//创建一个名为hello的点cpp文件。touch hello.cpp//在文件中写入内容//写完后保存关闭//打开终端输入,编译C加加文件g++ hello.cpp -o hello//执行可执行文件。./hello//同理。执行python文件python hello.py ros安装 1234567891011121314151617181920//添加ros软件源sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; //添加密匙sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 //安装rossudo apt updatesudo apt install ros-melodic-desktop-full //初始化rosdepsudo rosdep initrosdep update //设置环境变量echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc //安装rosinstallsudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 鱼香ros一键安装 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 小乌龟实例 123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 创建工作空间 1234567891011121314//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_make //设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译 12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs geometry_msgs turtlesim //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash C++编译配置&lt;cmakelists.txt&gt;12add_executable($&#123;PROJECT_NAME&#125;_node src/my_package_name_node.cpp)target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;)自定义消息1.在功能包文件夹内创建msg文件夹，并新建Person.msg文件，在里面写入 1234567string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 2.在package.xml文件内添加依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.在CMakeLists.txt内加入： 123456789 add_message_files( FILES Person.msg) generate_messages( DEPENDENCIES std_msgs)并把1# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim改为1CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime系统关机及重启 1234//关机shutdown -h now//重启sudo reboot ctrl all+T打开新的终端 摄像头参数命令1qv4l2 launch文件启动rviz每次启动rviz都要设置订阅的话题、点云大小等等机械化的设置，为了方便快捷的操作，把rviz的设置写入launch文件内，就可以一键启动了。1.先启动需要运行的节点，再启动一个rviz；2.设置好订阅的话题、点云大小、坐标轴等需要用到的设置3.点击左上角的file，选择另存为到一个指定地址(功能包文件夹下创建config文件夹，rviz配置文件放里面)；4、写入launch文件 1234&lt;launch&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find my_package)/config/path_to_your_rviz_config_file.rviz&quot; /&gt;&lt;/launch&gt; 其中 find my_package 为你的功能包名，path_to_your_rviz_config_file.rviz为rviz文件名","tags":["ros"]},{"title":"零基础小白3d打印基本入门（2.0）","path":"/2023/07/24/3D打印入门基础/","content":"欢迎加入3d打印社温暖的大家庭本手册旨在帮助新同学完成3d打印从0到1的过程 第一步 建模软件的安装建模软件有很多，如有其他需求请自行查找。这里主要介绍一种，北矿的我们用的最多的软件。Solidwords Solidwords是工业建模软件，主要用于工业零部件的建模。安装其实有点小复杂。安装需谨慎，请严格按照规范进行。这玩意儿实际上是付费软件（用于学习的话，是可以白嫖的。），本人实际安装的时候，因为安装时出现一些差错。只能把电脑系统重装了软件图标 基本界面 具体安装方法下载路径：https://www.cadzxw.com/download.html打开网址后，菜单下拉。找到solidwords的一栏。选择最新版solidwords安装图文教程点击查看。 在此再次提醒各位，安装需谨慎，请严格按照安装操作进行。(我想你大概也不想重装电脑吧[狗头])不愿折腾的可选择淘宝远程指导，但十分不推荐。 按照上面的操作，一步一步的来就可以安装完毕了。下面进入到第二步 第二步 建模软件的学习依旧是以solidwords为例（如果安装了其他建模软件的话，请自行查找教程）在B站上可以找到学习的教程。这里推荐阿奇学solidwolds.https://www.bilibili.com/video/BV1iw411Z7HZ/链接如上。建模软件的学习，请自行按照视频进行。学习完了建模软件就可以开始3d打印了吗？还差最后一步。 第三步 开始3d打印首先需要一台电脑，一台打印机，一个U盘，一个已经建模好的模型。建模软件。切片软件。（当然了，模型也可以在各大网站上去找。）切片软件有很多，请自行查找。但是学校的打印机很垃圾。需要配备专门的切片软件，也就是说，市场上通用的切片软件，eg.cura实际上是用不了的。哦，也可以用，但是切出来的不能够用于学校的打印机，只能够用于自制的打印机，或者是其他品牌的打印机。专门的切片软件链接放在这里，请自行下载。https://cr.triority.cn/f/LRHZ/SHINING_Setup_5.2.6.exe切片软件图标:这个链接的存活取决于mjx学长服务器的存活时间.请注意保存。 3d打印模型的获取方式 blbl t站 建模软件手绘 (机械学生展示你的实力吧) 这里我将会演示一下。依旧是基于solidwords1.打开solidwords的已建好的模型。2.选择文件另存为（在这之前请保存好你的文件，快捷键Ctrl+s.如果已经保存，请忽略括号内容）3.点击后弹出界面如下图所示请选择文件名,并点击保存类型。找到stl格式.保存.(STL(Stereolithography)文件，有时被称为“标准三角语言”或“标准曲面细分语言”，由3D Systems于1987年创建，并且已被广泛用作全行业3D打印机模型的标准文件。)学校的打印机专用的切片软件只能识别stl格式.接下来会弹出一系列界面。选按照默认选择是就可以了。然后你的保存路径里会出现这样一文件。如图。(因为我直接保存在桌面上了)（这种文件一般发给淘宝商家就可以打印了。） 打开这个文件。会出现如下的界面右侧是调参界面。我简单的介绍一些重要的吧首先，右侧的材料一栏。(社团买的材料。主要是PLA，有时也有ABS。)然后就是添加支撑这一栏。如果说你的材料有镂空结构。请添加支撑。不然的话，打印的时候会塌掉。（当然，你也可以利用支撑的特性做出一些其他作品。）在此展示一下20级sk学长的作品。圣诞树.没有添加支撑。让其自然下落而形成的圣诞树结构。他的建模模型和实际图完全不一样。实际图是没有添加支撑的塌掉的建模模型。切片软件左侧一栏可以移动调整打印件的位置和方向。点击立方体打印件，左侧就会变成可选状态。常用功能有移动，缩放，旋转。（多尝试几遍就熟悉了。）摆好模型的位置。使它变成一个容易打印的状态。这一点比较重要，如果模型的位置和方向不好的话。可能会使打印机打印时失败。。 摆好模型的位置，并调整参数后。点击右下角的准备按钮。并插上U盘。这里建议最好用学校的U盘。自己的U盘的话，插上去可能会检测不出来。学校的U盘如上图。切片完成后，点击右下角的保存到可移动磁盘。拔出U盘，将U盘插入打印机。打印机全貌右上角是打印机的菜单界面，点击打印，下翻目录，找到我们要打印的立方体模型。点击三角形开始打印。这样我们只需要等待打印完成就可以了。 第四步 打印机的维护打印机的维护，包括内容有：（实际打印中，我们会碰到的最多的问题。）1.耗材安装2.打印机调平3.堵头问题怎么处理当然了，这里也放一个学校打印机的官方的维护视频的链接链接：https://pan.quark.cn/s/714267f196f7当然了，如果在实际使用过程中碰到了一些无法解决的问题，请积极的请教学长。因为实际维修的过程可能跟官方给的教程有很大差异。 附录 作品展示进阶 如何制作一台3d打印机https://www.bilibili.com/video/BV15N411o7ou?p=1&amp;vd_source","tags":["3d打印"]},{"title":"我的技术栈","path":"/2023/07/24/我的技术栈/","content":"我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32(未学) stm32(未学) 网络基础 树莓派 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"this is my blog","path":"/2023/07/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的个人博客联系邮箱：&#x33;&#51;&#49;&#x31;&#55;&#48;&#52;&#53;&#x30;&#x39;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109; 姓名：李无忧性别：男爱好：睡觉和吃饭以及听音乐性格：温和喜静理想：实现共产主义，追求社会公平讨厌的事：被他人意志所裹挟擅长的事：模仿与学习 为什么写博客？ 主要原因有二个方面吧，首先呢，记录学习状态。学习的时候很多代码确实很难记住，知道怎么用就好了，必要的时候翻翻个人博客就可以找到。然后吧，记录生活日常。当然这个可能比较少。"}]